/**
 * This script transforms the API reference folder generated by docfx into a Docusaurus-compatible folder with better navigation and fixed markdown.
 */

const fs = require('node:fs');
const path = require('node:path');
const yaml = require('js-yaml');


/**
 * Load the content of a YAML file.
 * @param {string} filePath - The path of the YAML file to load.
 */
function loadYamlFile(filePath) {
    try {
        const fileContent = fs.readFileSync(filePath, 'utf-8');
        return yaml.load(fileContent, {});
    } catch (e) {
        console.error(`Error reading YAML file "${filePath}": ${e}`);
        process.exit(1);
    }
}


/**
 * Singularize a word.
 * @param {string} word - The word to singularize.
 */
function singularizeWord(word) {
    const mapping = {
        "Classes": "Class",
        "Interfaces": "Interface",
        "Enums": "Enum",
        "Namespaces": "Namespace",
    }
    return mapping[word] || word.slice(0, -1);
}


/**
 * Build the navigation structure of the API reference.
 * @param tocContent - The table of content.
 */
function buildNavigation(tocContent) {
    const navigation = {}; // [href]: {href, title, sidebar_position}
    let parentIndex = 0;
    const parentSection = `Namespaces`;
    const parentPrefix = `${singularizeWord(parentSection)} `;

    for (const rootItem of tocContent) {
        if (!rootItem.href) {
            console.warn(`Root item ${rootItem.name} has no href.`);
            continue;
        }
        const rootItemStem = rootItem.href.split('.').slice(0, -1).join('.');
        const rootItemBreadcrumb = [rootItemStem, 'README.md'];

        // add index document
        navigation[rootItem.href] = {
            href: rootItemBreadcrumb.join('/'),
            href_levels: rootItemBreadcrumb.length,
            title: `${parentPrefix}${rootItem.name}`,
            sidebar_position: ++parentIndex,
        }

        // add children
        if (rootItem.items) {
            let childIndex = 0;
            let childSection = '';
            let childPrefix = '';
            for (const childItem of rootItem.items) {
                if (!childItem.href) {
                    childSection = childItem.name;
                    childPrefix = `${singularizeWord(childSection)} `;
                    continue;
                }
                const childItemStem = childItem.href.replace(rootItemStem, '').split('.').filter(Boolean);
                const childItemName = childItemStem.join('.');
                const childBreadcrumb = [rootItemStem, childSection, childItemName].filter(Boolean);
                navigation[childItem.href] = {
                    href: childBreadcrumb.join('/'),
                    href_levels: childBreadcrumb.length,
                    title: `${childPrefix}${childItem.name}`,
                    sidebar_position: ++childIndex,
                }
            }
        }
    }
    return navigation;
}

/**
 * Update file content according to new navigation.
 * @param {string} file - The file to update.
 * @param {string} content - The content of the file to update.
 * @param navigation - The new navigation.
 */
function updateFileContent(file, content, navigation) {
    let updatedContent = content;
    const fileNavigation = navigation[file];

    // Replace hrefs
    for (const [key, value] of Object.entries(navigation)) {
        const oldString = key.replace("-", "\\-");
        const newString = '../'.repeat(fileNavigation.href_levels - 1) + value.href;
        updatedContent = updatedContent.replaceAll(oldString, newString);
    }

    // fix links when wrapped on <>
    updatedContent = updatedContent.replaceAll(")\\>", ") >");

    return updatedContent;
}


/**
 * Extract title from the content of a file.
 * @param {string} content - The content of the file.
 */
function extractTitle(content) {
    const firstLine = content.split('\n')[0];
    const parts = firstLine.split('</a> ')
    return parts[parts.length - 1].replaceAll("\\", "").trim();
}


/**
 * Transforms the API reference folder by processing each file.
 * @param {string} relativePath - The relative path of the API folder to process.
 */
function transformApiReferenceFolder(relativePath) {
    const folderPath = path.resolve(relativePath);

    // Check if the folder exists
    if (!fs.existsSync(folderPath)) {
        console.error(`The folder "${folderPath}" does not exist.`);
        process.exit(1);
    }

    // check if toc.yml file exists
    const tocPath = path.join(folderPath, 'toc.yml');
    if (!fs.existsSync(tocPath)) {
        console.error(`The table of content file "${tocPath}" does not exist.`);
        process.exit(1);
    }

    // load table of content
    const tocContent = loadYamlFile(tocPath);
    console.log('Table of content:');
    console.log(tocContent);

    // remove toc.yml file
    fs.unlinkSync(tocPath);

    // build navigation
    console.log('Navigation:');
    const navigation = buildNavigation(tocContent);
    console.log(navigation);

    // Read all files in the folder
    const files = fs.readdirSync(folderPath);

    // Process each file
    files.forEach((file) => {
        const filePath = path.join(folderPath, file);
        if (file.endsWith('.md')) {
            if (!(file in navigation)) {
                console.error(`File ${file} is not in the navigation.`);
                process.exit(1);
            }
            console.log(`Processing file: ${file}`);
            const fileNavigation = navigation[file];

            // Update content
            const updatedContent = updateFileContent(file, fs.readFileSync(filePath, 'utf-8'), navigation);
            const frontMatter = `---\ntitle: "${extractTitle(updatedContent)}"\nsidebar_position: ${fileNavigation.sidebar_position}\n---\n\n`;

            // Prepare new file
            const newPath = path.join(folderPath, fileNavigation.href);
            const newContent = frontMatter + updatedContent;

            // create parent folder if not exists
            const parentFolder = path.dirname(newPath);
            if (!fs.existsSync(parentFolder)) {
                fs.mkdirSync(parentFolder, {recursive: true});
            }

            // write new file
            fs.writeFileSync(newPath, newContent, 'utf-8');

            // remove old file
            fs.unlinkSync(filePath);
        }
    });
}

/**
 * Entry point of the script.
 * @param argv
 */
function main(argv) {
    // Parse the path argument
    const args = argv.slice(2);
    const pathArg = args.find(arg => arg.startsWith('--path='));
    if (!pathArg) {
        console.error('Usage: yarn run transform-api-folder --path=<relative-folder-path>');
        process.exit(1);
    }
    const pathParts = pathArg.split('=');
    if (pathParts?.length !== 2) {
        console.error('Error: Invalid "--path" value.');
        process.exit(1);
    }
    const relativePath = pathParts[1];

    // Transform the API reference folder
    transformApiReferenceFolder(relativePath);
}

// Run the main function
main(process.argv);
